<!DOCTYPE html>
<html>
  <head>
    <title>Test Page For Element Tracking Plugin</title>
    <script>
      (function (p, l, o, w, i, n, g) {
        if (!p[i]) {
          p.GlobalSnowplowNamespace = p.GlobalSnowplowNamespace || [];
          p.GlobalSnowplowNamespace.push(i);
          p[i] = function () {
            (p[i].q = p[i].q || []).push(arguments);
          };
          p[i].q = p[i].q || [];
          n = l.createElement(o);
          g = l.getElementsByTagName(o)[0];
          n.async = 1;
          n.src = w;
          g.parentNode.insertBefore(n, g);
        }
      })(
        window,
        document,
        'script',
        'https://cdn.jsdelivr.net/npm/@snowplow/javascript-tracker@3/dist/sp.js',
        'snowplow'
      );

      snowplow('newTracker', 'sp', 'http://localhost:9090', {});
      snowplow(
        'addPlugin',
        'dist/index.umd.js',
        ['snowplowElementTracking', 'SnowplowElementTrackingPlugin'],
        [
          {
            ignoreNextPageview: true,
          },
        ]
      ); // we assume the plugin is instantiated before the first pageview is tracked; set ignoreNextPageview to false if not the case. this only matters if you use `when: pageview` shown later; the pageview event that is seen will reset the pageview state so you might accidentally double-track
    </script>
    <style>
      body {
        min-height: 400vh;
        display: flex;
        flex-flow: column nowrap;
        justify-content: space-between;
      }
    </style>

    <body>
      <div class="oncreate" data-example="from dataset"><span>This is: </span>Some text content</div>
      <a href="/">A link</a>
      <div class="mutatetest">This div will change</div>
      <div class="perpage">This one too, but tracked once per pageview</div>
      <shadow-host></shadow-host>

      <div class="recommendations">
        <h2>Recommended for You</h2>
        <ul>
          <li>Item A<img alt="A" src="" /></li>
          <li>Item B<img alt="B" src="" /></li>
          <li>Item C<img alt="C" src="" /></li>
          <li>Item D<img alt="D" src="" /></li>
        </ul>
      </div>

      <div class="recommendations second-set">
        <h2>Others also liked:</h2>
        <ul>
          <li>Item E</li>
          <li>Item F</li>
          <li>Item G</li>
          <li>Item H</li>
        </ul>
      </div>

      <script>
        window.customElements.define(
          'shadow-host',
          class extends HTMLElement {
            connectedCallback() {
              const b = document.createElement('button');
              b.type = 'button';
              b.className = 'shadow';
              b.textContent = 'Shadow';

              const shadowRoot = this.attachShadow({ mode: 'open' });
              shadowRoot.appendChild(b);
            }
          }
        );
      </script>

      <script>
        snowplow('startElementTracking', {
          elements: [
            // can be a single or array of many configurations; additive, can be called multiple times to add more configs, but doesn't dedupe
            {
              selector: '.oncreate', // required: selector for element, relative to document scope
              name: 'created div', // logical name: can be shared across multiple configs; defaults to `selector` if not specified; this is used in event payloads and as a key to reference entities
              create: true, // track an event when the element is added to the DOM (or when plugin loads if already on page) (default: false)
              destroy: true, // track an event when the element is removed from the DOM (or when plugin loads if already on page) (default: false)
              expose: true, // track an event when the element intersects with the viewport (default: true)
              obscure: true, // track an event when the element scrolls out of the viewport (default: false)
              details: [
                // details can be extracted from the element and included in the entity
                function (element) {
                  return { example: 'from a function' };
                }, // use a function that returns an object
                { attributes: ['class'], selector: true }, // or declarative options; either as a single object or array elements if you want config re-use; this is less flexible but will be useful to Google Tag Manager where functions may not be able to reference DOM elements
                { attributes: ['class'] }, // attributes: get the static/default attributes originally defined on the element when created
                { properties: ['className'] }, // properties: get the dynamic/current attributes defined on the element
                { dataset: ['example'] }, // dataset: extract values from dataset attributes
                { child_text: { heading: 'h2' } }, // child_text: for each given name:selector pair, extract the textContent of the first child matching selector, if it has text content use that value with the given name; if there's no matching children it will try shadow children
                { selector: true }, // selector: attach the matching CSS selector as an attribute; useful if you're using logical names but want to differentiate
                { content: { textType: /text (\S+)/ } }, //content (map of regex patterns to match text against, first capture group used if detected); if no innerText, will try shadow innerText
              ],
              includeStats: ['page_ping'], // you can include a list of event names here; statistics about elements matching this configuration will be attached as entities to those events; event names don't have to be generated by this plugin so can include built-in events like page_pings or custom events
            },
            { selector: 'body', expose: false, component: true }, // expose is true by default; component means the name/selector is attached to the component_parents entity list for other events
            {
              selector: '.mutatetest.toggled', // elements that exist but don't yet match the selector will count as created/destroyed if they later are changed to match it
              name: 'mutated div',
              create: true,
              destroy: true,
              expose: false,
              obscure: false,
            },
            {
              selector: '.perpage.toggled',
              name: 'perpage mutation',
              create: { when: 'pageview' }, // for each type of event you can specify frequency caps for when the event will fire: never, always, once, element, pageview
              destroy: { when: 'pageview' },
              /*
              the frequency options are "per":
               - per never will never track the event, effectively disabling the configuration
               - per always will track an event every time it is eligible (e.g. every time on screen when scrolled past)
               - per once will only track the event a single time for each configuration for the duration of the plugin instance; this reduces volume since only the first matching element will fire the event
               - per element is like once, but for each individually matching element instance
               - per pageview is like once, but useful for single-page-applications with long-lasting plugin instances where you may want to track the element on each virtual pageview
              */
              expose: false, // `false` is equivalent to `when: never`, and `true` is `when: always`
              obscure: false,
            },
            {
              name: 'recommendations',
              selector: '.recommendations',
              expose: {
                // expose has more options than the other events:
                minTimeMillis: 5000, // cumulative time in milliseconds that each matching element should be visible for before considered exposed
                minPercentage: 0, // the minimum percentage of the element's area that should be visible before considering exposed; range 0.0 - 1.0
                minSize: 0, // the minimum size the element should be before being considered expose; this can be used to ignore elements with 0 size
                boundaryPixels: 0, // arbitrary margins to apply to the element when calculating minPercentage; can be a number to apply to all sides, 2-element array to specify vertical and horizontal, or 4-element array to specify margins for each size individually
              },
              obscure: true,
              component: true,
              details: { child_text: ['h2'] },
              contents: [
                // content information can be extracted
                {
                  name: 'recommendation-item', // contents can be named too
                  selector: 'li', // selectors are relative to the parent element
                  details: { content: { item_name: /.+/ } }, // content item details can be captured too
                  contents: { name: 'recommendation_image', selector: 'img', details: { attributes: ['alt'] } },
                },
              ],
            },
            {
              name: 'shadow',
              selector: 'button.shadow',
              shadowSelector: 'shadow-host', // elements within custom components/shadow hosts require their hosts' selectors to be specified
              shadowOnly: true, // if the selector could erroneously catch elements outside your shadow hosts, you can restrict it to only match in shadows; by default it will match elements in and out of shadow hosts if they match the selector
            },
          ],
        });

        snowplow('getComponentListGenerator', function (componentGenerator, componentGeneratorWithDetail) {
          // access a context generator aware of the startElementTracking configuration "components"
          snowplow('enableLinkClickTracking', { context: [componentGenerator] });
          snowplow('enableFormTracking', { context: [componentGenerator] });

          // componentGeneratorWithDetail will also populate element_detail entities for each component, but may not be directly compatible with the above APIs
        });
        snowplow('enableActivityTracking', {minimumVisitLength: 5, heartbeatDelay: 10});
        snowplow('trackPageView');

        setInterval(() => {
          document.querySelector('.mutatetest').classList.toggle('toggled');
          document.querySelector('.perpage').classList.toggle('toggled');
        }, 3000);

        setInterval(snowplow, 15000, 'trackPageView');
      </script>
    </body>
  </head>
</html>
